import json
import argparse
from datetime import datetime
from collections import Counter
from pathlib import Path
from typing import Dict, Any


def process_date_field(date_field: Any) -> datetime:
    """Convert $date fields from Unix timestamp (ms) to datetime objects"""
    if isinstance(date_field, dict) and '$date' in date_field:
        return datetime.utcfromtimestamp(date_field['$date'] / 1000)
    return date_field


def analyze_incident_log(file_path: str) -> Dict[str, Any]:
    """
    Parse incident log and collect region and description statistics

    Args:
        file_path: Path to the JSON log file

    Returns:
        dict: Analysis results with counters and metadata
    """
    row_count = 0
    error_count = 0

    # Counters for region analysis
    county_counts = Counter()
    municipality_counts = Counter()
    state_counts = Counter()

    # Counter for descriptions
    description_counts = Counter()

    # Track missing fields
    missing_fields = Counter()

    print(f"Reading file: {file_path}")

    # Validate file exists
    if not Path(file_path).exists():
        raise FileNotFoundError(f"File not found: {file_path}")

    # Stream the file line by line
    with open(file_path, 'r', encoding='utf-8') as f:
        for line_num, line in enumerate(f, 1):
            line = line.strip()
            if not line:  # Skip empty lines
                continue

            try:
                record = json.loads(line)
                row_count += 1

                # Count by region fields
                if record.get('county'):
                    county_counts[record['county']] += 1
                else:
                    missing_fields['county'] += 1

                if record.get('municipality'):
                    municipality_counts[record['municipality']] += 1
                else:
                    missing_fields['municipality'] += 1

                if record.get('state'):
                    state_counts[record['state']] += 1
                else:
                    missing_fields['state'] += 1

                # Count descriptions
                if record.get('description'):
                    description_counts[record['description']] += 1
                else:
                    missing_fields['description'] += 1

            except json.JSONDecodeError as e:
                error_count += 1
                print(f"WARNING Line {line_num}: JSON decode error - {e}")
            except Exception as e:
                error_count += 1
                print(f"WARNING Line {line_num}: Unexpected error - {e}")

    return {
        'total_records': row_count,
        'error_count': error_count,
        'county_counts': county_counts,
        'municipality_counts': municipality_counts,
        'state_counts': state_counts,
        'description_counts': description_counts,
        'missing_fields': missing_fields
    }


def write_descriptions_to_file(results: Dict[str, Any], output_file: str, top_n: int = None):
    """
    Write incident descriptions to a separate text file

    Args:
        results: Analysis results dictionary
        output_file: Path to output text file
        top_n: Limit output to top N results (None = show all)
    """
    total = results['total_records']
    desc_items = sorted(results['description_counts'].items(), key=lambda x: x[1], reverse=True)
    if top_n:
        desc_items = desc_items[:top_n]

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write("=" * 80 + "\n")
        f.write(f"INCIDENT DESCRIPTIONS{f' (Top {top_n})' if top_n else ''}\n")
        f.write("=" * 80 + "\n")
        f.write(f"Total unique descriptions: {len(results['description_counts'])}\n")
        f.write(f"Total incidents analyzed: {total:,}\n\n")

        for description, count in desc_items:
            percentage = (count / total) * 100
            f.write(f"{description:50} {count:>8,} ({percentage:>6.2f}%)\n")

        f.write("\n" + "=" * 80 + "\n")
        f.write("End of Incident Descriptions Report\n")
        f.write("=" * 80 + "\n")

    print(f"Incident descriptions written to: {output_file}")


def print_summary(results: Dict[str, Any], top_n: int = None):
    """
    Print formatted analysis summary

    Args:
        results: Analysis results dictionary
        top_n: Limit output to top N results per category (None = show all)
    """
    total = results['total_records']

    print("\n" + "=" * 80)
    print("SUMMARY")
    print("=" * 80)
    print(f"Total Incidents: {total:,}")
    print(f"Parse Errors: {results['error_count']:,}")

    if results['missing_fields']:
        print("\nMissing Field Counts:")
        for field, count in results['missing_fields'].items():
            print(f"  {field}: {count:,} ({(count / total) * 100:.2f}%)")

    # States
    print("\n" + "=" * 80)
    print(f"COUNTS BY STATE{f' (Top {top_n})' if top_n else ''}")
    print("=" * 80)
    state_items = sorted(results['state_counts'].items(), key=lambda x: x[1], reverse=True)
    if top_n:
        state_items = state_items[:top_n]
    for state, count in state_items:
        percentage = (count / total) * 100
        print(f"{state:30} {count:>8,} ({percentage:>6.2f}%)")

    # Counties
    print("\n" + "=" * 80)
    print(f"COUNTS BY COUNTY{f' (Top {top_n})' if top_n else ''}")
    print("=" * 80)
    county_items = sorted(results['county_counts'].items(), key=lambda x: x[1], reverse=True)
    if top_n:
        county_items = county_items[:top_n]
    for county, count in county_items:
        percentage = (count / total) * 100
        print(f"{county:30} {count:>8,} ({percentage:>6.2f}%)")

    # Municipalities
    print("\n" + "=" * 80)
    print(f"COUNTS BY MUNICIPALITY{f' (Top {top_n})' if top_n else ''}")
    print("=" * 80)
    municipality_items = sorted(results['municipality_counts'].items(), key=lambda x: x[1], reverse=True)
    if top_n:
        municipality_items = municipality_items[:top_n]
    for municipality, count in municipality_items:
        percentage = (count / total) * 100
        print(f"{municipality:30} {count:>8,} ({percentage:>6.2f}%)")

    print("\n" + "=" * 80)
    print("Analysis Complete")
    print("=" * 80)


def export_to_json(results: Dict[str, Any], output_file: str):
    """Export analysis results to JSON file"""
    # Convert Counter objects to regular dicts for JSON serialization
    export_data = {
        'total_records': results['total_records'],
        'error_count': results['error_count'],
        'county_counts': dict(results['county_counts']),
        'municipality_counts': dict(results['municipality_counts']),
        'state_counts': dict(results['state_counts']),
        'description_counts': dict(results['description_counts']),
        'missing_fields': dict(results['missing_fields'])
    }

    with open(output_file, 'w', encoding='utf-8') as f:
        json.dump(export_data, f, indent=2)

    print(f"Results exported to: {output_file}")


def main():
    parser = argparse.ArgumentParser(description='Analyze incident log JSON files')
    parser.add_argument('input_file', help='Path to incident log JSON file')
    parser.add_argument('--top', type=int, help='Show only top N results per category')
    parser.add_argument('--export', help='Export results to JSON file')
    parser.add_argument('--descriptions', default='incident_descriptions.txt',
                        help='Output file for incident descriptions (default: incident_descriptions.txt)')

    args = parser.parse_args()

    try:
        print("Analyzing incident log...\n")
        results = analyze_incident_log(args.input_file)
        print_summary(results, top_n=args.top)

        # Always write descriptions to file
        write_descriptions_to_file(results, args.descriptions, top_n=args.top)

        if args.export:
            export_to_json(results, args.export)

    except FileNotFoundError as e:
        print(f"ERROR: {e}")
    except Exception as e:
        print(f"ERROR: Unexpected error: {e}")
        raise


if __name__ == "__main__":
    # If no command-line args, use default file path
    import sys

    if len(sys.argv) == 1:
        default_file = ''
        print("Analyzing incident log...\n")
        results = analyze_incident_log(default_file)
        print_summary(results)
        write_descriptions_to_file(results, 'incident_descriptions.txt')
    else:
        main()
